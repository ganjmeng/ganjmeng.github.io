{"meta":{"title":"感觉萌的Blog","subtitle":"欲罢不能，想想都有点小激动。","description":"欲罢不能，想想都有点小激动。","author":"Gan Meng","url":"http://ganmmeng.cn"},"pages":[{"title":"categories","date":"2016-05-09T03:23:34.000Z","updated":"2016-05-09T03:23:34.000Z","comments":true,"path":"categories/index-1.html","permalink":"http://ganmmeng.cn/categories/index-1.html","excerpt":"","keywords":null,"text":"","raw":null,"content":null},{"title":"categories","date":"2016-04-29T07:50:28.000Z","updated":"2016-04-29T07:50:28.000Z","comments":true,"path":"categories/index.html","permalink":"http://ganmmeng.cn/categories/index.html","excerpt":"","keywords":null,"text":"","raw":null,"content":null},{"title":"about","date":"2016-04-29T08:51:57.000Z","updated":"2016-05-06T02:05:06.000Z","comments":true,"path":"about/index.html","permalink":"http://ganmmeng.cn/about/index.html","excerpt":"","keywords":null,"text":"DillingerDillinger is a cloud-enabled, mobile-ready, offline-storage, AngularJS powered HTML5 Markdown editor. Type some Markdown on the left See HTML in the right Magic Markdown is a lightweight markup language based on the formatting conventions that people naturally use in email. As John Gruber writes on the Markdown site The overriding design goal for Markdown’sformatting syntax is to make it as readableas possible. The idea is that aMarkdown-formatted document should bepublishable as-is, as plain text, withoutlooking like it’s been marked up with tagsor formatting instructions. This text you see here is actually written in Markdown! To get a feel for Markdown’s syntax, type some text into the left window and watch the results in the right. Version3.2.7 TechDillinger uses a number of open source projects to work properly: AngularJS - HTML enhanced for web apps! Ace Editor - awesome web-based text editor markdown-it - Markdown parser done right. Fast and easy to extend. Twitter Bootstrap - great UI boilerplate for modern web apps node.js - evented I/O for the backend Express - fast node.js network app framework @tjholowaychuk Gulp - the streaming build system keymaster.js - awesome keyboard handler lib by @thomasfuchs jQuery - duh And of course Dillinger itself is open source with a public repository on GitHub. InstallationDillinger requires Node.js v4+ to run. You need Gulp installed globally: 1$ npm i -g gulp 12345$ git clone [git-repo-url] dillinger$ cd dillinger$ npm i -d$ gulp build --prod$ NODE_ENV=production node app PluginsDillinger is currently extended with the following plugins Dropbox Github Google Drive OneDrive Readmes, how to use them in your own application can be found here: plugins/dropbox/README.md plugins/github/README.md plugins/googledrive/README.md plugins/onedrive/README.md DevelopmentWant to contribute? Great! Dillinger uses Gulp + Webpack for fast developing.Make a change in your file and instantanously see your updates! Open your favorite Terminal and run these commands. First Tab:1$ node app Second Tab:1$ gulp watch (optional) Third:1$ karma start DockerDillinger is very easy to install and deploy in a Docker container. By default, the Docker will expose port 80, so change this within the Dockerfile if necessary. When ready, simply use the Dockerfile to build the image. 12cd dillingerdocker build -t &lt;youruser&gt;/dillinger:latest . This will create the dillinger image and pull in the necessary dependencies. Once done, run the Docker and map the port to whatever you wish on your host. In this example, we simply map port 80 of the host to port 80 of the Docker (or whatever port was exposed in the Dockerfile): 1docker run -d -p 80:80 --restart=\"always\" &lt;youruser&gt;/dillinger:latest Verify the deployment by navigating to your server address in your preferred browser. N|Solid and NGINXMore details coming soon. docker-compose.ymlChange the path for the nginx conf mounting path to your full path, not mine! Todos Write Tests Rethink Github Save Add Code Comments Add Night Mode LicenseMIT Free Software, Hell Yeah!","raw":null,"content":null},{"title":"tags","date":"2016-05-09T03:23:16.000Z","updated":"2016-05-09T03:23:16.000Z","comments":true,"path":"tags/index-1.html","permalink":"http://ganmmeng.cn/tags/index-1.html","excerpt":"","keywords":null,"text":"","raw":null,"content":null},{"title":"iOS Developer","date":"2016-04-29T04:39:04.000Z","updated":"2016-04-29T09:45:14.000Z","comments":true,"path":"tags/index.html","permalink":"http://ganmmeng.cn/tags/index.html","excerpt":"","keywords":null,"text":"","raw":null,"content":null}],"posts":[{"title":"[转载]Eclipse for Mac 常用快捷键","slug":"untitled-1466390002267","date":"2016-06-20T02:33:22.000Z","updated":"2016-06-20T02:42:46.000Z","comments":true,"path":"2016/06/20/untitled-1466390002267/","link":"","permalink":"http://ganmmeng.cn/2016/06/20/untitled-1466390002267/","excerpt":"原文地址：Eclipse for Mac 常用快捷键作者： 西可韦 为了提高开发效率，Eclipse 为我们提供了许多快捷键，它们能够帮助我们快速和方便的完成一些繁琐的操作。 关于 Eclipse for Windows 的快捷键，在百度和谷歌等搜索引擎都可以搜索到，在这里只提供Eclipse for Mac 的常用快捷键。我并不打算把所有的快捷键都罗列出来，那样非常没有必要。Command + O：显示大纲Command + 1：快速修复Command + D：删除当前行Command + Option + ↓：复制当前行到下一行Command + Option + ↑：复制当前行到上一行Option + ↓：当前行和下面一行交互位置Option + ↑：当前行和上面一行交互位置Option + ←：前一个编辑的页面Option + →：下一个编辑的页面","keywords":null,"text":"原文地址：Eclipse for Mac 常用快捷键作者： 西可韦 为了提高开发效率，Eclipse 为我们提供了许多快捷键，它们能够帮助我们快速和方便的完成一些繁琐的操作。 关于 Eclipse for Windows 的快捷键，在百度和谷歌等搜索引擎都可以搜索到，在这里只提供Eclipse for Mac 的常用快捷键。我并不打算把所有的快捷键都罗列出来，那样非常没有必要。Command + O：显示大纲Command + 1：快速修复Command + D：删除当前行Command + Option + ↓：复制当前行到下一行Command + Option + ↑：复制当前行到上一行Option + ↓：当前行和下面一行交互位置Option + ↑：当前行和上面一行交互位置Option + ←：前一个编辑的页面Option + →：下一个编辑的页面 Option + Return：显示当前选择资源的属性Shift + Return：在当前行的下一行插入空行Shift + Control + Return：在当前行插入空行Control + Q：定位到最后编辑的地方Control + M：最大化当前的Edit或View（再按则最小化）Control + /：注释当前行，再按则取消注释Command + T：快速显示当前类的继承结构Command + W：关闭当前EditerCommand + K：参照当前选中的Word快速定位到下一个Command + E：快速显示当前Editer的下拉列表（如果当前页面没有显示的用黑体表示）Option + /：代码助手完成一些代码的插入（俗称“智能提示”）Command + Shift + E：显示管理当前打开的所有的View的管理器Command + J：正向增量查找（按下Command + J后，你所输入的每个字母编辑器都提供快速匹配定位到某个单词，如果没有，则在Stutes Line中显示没有找到了）Command + Shift + J：反向增量查找Command + Shift + W：关闭所有打开的EditerCommand + Shift + X：把当前选中的文本全部变为大写Command + Shift + Y：把当前选中的文本全部变为小写Command + Shift + F：格式化当前代码Command + Shift + P：定位到对于的匹配符（譬如{}）（从前面定位后面时，光标要在匹配符里面，后面到前面，则反之）Option + Command + R：重命名（尤其是变量和类的Rename效果比较明显）Option + Shift + M：抽取方法（这是重构里面最常用的方法之一了，尤其是对一大堆泥团代码有用）Option + Command + C：修改函数结构（有N个函数调用了这个方法，修改一次就搞定）Option + Command + L：抽取本地变量（可以直接把一些魔法数字和字符串抽取成一个变量，尤其是多处调用的时候）Option + Shift + F：把Class中的Local变量变为Field变量（比较实用的功能）Option + Command + Z：重构的后悔药（Undo）","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://ganmmeng.cn/categories/Java/"},{"name":"Eclipse","slug":"Java/Eclipse","permalink":"http://ganmmeng.cn/categories/Java/Eclipse/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://ganmmeng.cn/tags/Java/"},{"name":"Eclipse","slug":"Eclipse","permalink":"http://ganmmeng.cn/tags/Eclipse/"}]},{"title":"Block 高级进阶","slug":"untitled-1466044983663","date":"2016-06-16T02:43:03.000Z","updated":"2016-06-16T02:56:29.000Z","comments":true,"path":"2016/06/16/untitled-1466044983663/","link":"","permalink":"http://ganmmeng.cn/2016/06/16/untitled-1466044983663/","excerpt":"Block学习笔记 Block的类型与内存管理 根据Block在内存中的位置分为三种类型 NSGlobalBlock：类似函数，位于text段，全局的静态 block，不会访问任何外部变量 NSStackBlock：保存在栈中的 block，当函数返回时会被销毁 NSMallocBlock：保存在堆中的 block，当引用计数为 0 时会被销毁。 在MRC和ARC下还是有区别的 MRC 下的 Block的三种类型 1234567891011121314151617181920/*------------在MRC下-----------------*/ typedef test (^MyBlock)(int, int); MyBlock block1 = ^ test (int a, int b) &#123; return a + b; &#125;; NSLog(@\"block1 = %@\", block1); // block1 = &lt;__NSGlobalBlock__: 0x86f0&gt; int temp = 100; MyBlock block2 = ^ test (int a, int b) &#123; return temp + a + b; &#125;; NSLog(@\"block2 = %@\", block2); // block2 = &lt;__NSStackBlock__: 0xddf24a1&gt; //copy MyBlock block3 = [[block2 copy] autorelease]; NSLog(@\"block3 = %@\", block3); // block3 = &lt;__NSMallocBlock__: 0x75425a0&gt; block1没有使用任何外部变量，因此存储在 代码区，编译器给其的类型为NSGlobalBlockblock2使用到了局部变量，在定义（注意是定义，不是运行）block2时，局部变量temp当前值被copy到栈上，作为常量供Block使用(之前有提过，所以在block中不可以随意修改外面定义的局部变量)。编译器给其类型为NSStackBlockblock3 经过拷贝，局部变量 temp 的值被 copy 到堆中，编译器给其类型为NSMallocBlock 总结说来，block 的类型取决于内部使用的变量在哪。 ARC 下的 Block 123456789101112131415161718192021/*------------在ARC下-----------------*/typedef test (^MyBlock)(int, int);MyBlock block1 = ^ test (int a, int b) &#123; return a + b;&#125;;NSLog(@\"block1 = %@\", block1);// block1 = &lt;__NSGlobalBlock__: 0x10010030&gt;int temp = 100;MyBlock block2 = ^ test (int a, int b) &#123; return temp + a + b;&#125;;NSLog(@\"block2 = %@\", block2);// block2 = &lt;__NSMallocBlock__: 0x100102df0&gt;__block int sum = 100;MyBlock block3 = ^ test (int a, int b) &#123; return sum + a + b;&#125;;NSLog(@\"block3 = %@\", block3);// block3 = &lt;__NSMallocBlock__: 0x100306110&gt; 因为 ARC 下，编译器帮我们管理内存，所以只要内部调用了外部变量，编译器都会 copy一份变量到堆中，并且引用计数增加。 所以block2和block3的类型都是NSMallocBlock。其余和 MRC一样。 Tips Tips:以下情况，block 会拷贝到堆：*当 block 调用 copy方法时，如果block 在栈上，会被拷贝到堆上；*当 block 作为函数返回值返回时，编译器自动调用copy方法；*当 block 被赋值给_strong id类型的对象或block 的成员变量时，编译器自动将 block 作为Block_copy函数，效果等同于 block 直接调用copy方法；*当block作为参数被传入方法名带有usingBlock 的Cocoa Framework方法或 GCD的API 时。这些方法会在内部对传递进来的 block 调用copy或_Block_copy进行拷贝;","keywords":null,"text":"Block学习笔记 Block的类型与内存管理 根据Block在内存中的位置分为三种类型 NSGlobalBlock：类似函数，位于text段，全局的静态 block，不会访问任何外部变量 NSStackBlock：保存在栈中的 block，当函数返回时会被销毁 NSMallocBlock：保存在堆中的 block，当引用计数为 0 时会被销毁。 在MRC和ARC下还是有区别的 MRC 下的 Block的三种类型 1234567891011121314151617181920/*------------在MRC下-----------------*/ typedef test (^MyBlock)(int, int); MyBlock block1 = ^ test (int a, int b) &#123; return a + b; &#125;; NSLog(@\"block1 = %@\", block1); // block1 = &lt;__NSGlobalBlock__: 0x86f0&gt; int temp = 100; MyBlock block2 = ^ test (int a, int b) &#123; return temp + a + b; &#125;; NSLog(@\"block2 = %@\", block2); // block2 = &lt;__NSStackBlock__: 0xddf24a1&gt; //copy MyBlock block3 = [[block2 copy] autorelease]; NSLog(@\"block3 = %@\", block3); // block3 = &lt;__NSMallocBlock__: 0x75425a0&gt; block1没有使用任何外部变量，因此存储在 代码区，编译器给其的类型为NSGlobalBlockblock2使用到了局部变量，在定义（注意是定义，不是运行）block2时，局部变量temp当前值被copy到栈上，作为常量供Block使用(之前有提过，所以在block中不可以随意修改外面定义的局部变量)。编译器给其类型为NSStackBlockblock3 经过拷贝，局部变量 temp 的值被 copy 到堆中，编译器给其类型为NSMallocBlock 总结说来，block 的类型取决于内部使用的变量在哪。 ARC 下的 Block 123456789101112131415161718192021/*------------在ARC下-----------------*/typedef test (^MyBlock)(int, int);MyBlock block1 = ^ test (int a, int b) &#123; return a + b;&#125;;NSLog(@\"block1 = %@\", block1);// block1 = &lt;__NSGlobalBlock__: 0x10010030&gt;int temp = 100;MyBlock block2 = ^ test (int a, int b) &#123; return temp + a + b;&#125;;NSLog(@\"block2 = %@\", block2);// block2 = &lt;__NSMallocBlock__: 0x100102df0&gt;__block int sum = 100;MyBlock block3 = ^ test (int a, int b) &#123; return sum + a + b;&#125;;NSLog(@\"block3 = %@\", block3);// block3 = &lt;__NSMallocBlock__: 0x100306110&gt; 因为 ARC 下，编译器帮我们管理内存，所以只要内部调用了外部变量，编译器都会 copy一份变量到堆中，并且引用计数增加。 所以block2和block3的类型都是NSMallocBlock。其余和 MRC一样。 Tips Tips:以下情况，block 会拷贝到堆：*当 block 调用 copy方法时，如果block 在栈上，会被拷贝到堆上；*当 block 作为函数返回值返回时，编译器自动调用copy方法；*当 block 被赋值给_strong id类型的对象或block 的成员变量时，编译器自动将 block 作为Block_copy函数，效果等同于 block 直接调用copy方法；*当block作为参数被传入方法名带有usingBlock 的Cocoa Framework方法或 GCD的API 时。这些方法会在内部对传递进来的 block 调用copy或_Block_copy进行拷贝; Objective-C Blocks Quiz Example A123456void exampleA() &#123; char a = 'A'; ^&#123; printf(\"%cn\", a); &#125;();&#125; Always works ExplainThis always works. The stack for exampleA doesn’t go away until after the block has finished executing. So whether the block is allocated on the stack or the heap, it will be valid when it is executed. 直到 block 运行结束之前， 函数exampleA不会消失，所以不管 block 在堆中还是栈中，它在执行时都是有效的。 Example B1234567891011121314void exampleB_addBlockToArray(NSMutableArray *array) &#123; char b = 'B';//add a block as a object [array addObject:^&#123; printf(\"%cn\", b); &#125;];&#125;void exampleB() &#123; NSMutableArray *array = [NSMutableArray array]; exampleB_addBlockToArray(array); void (^block)() = [array objectAtIndex:0]; block();&#125; Only works in ARC ExplainWithout ARC, the block is an NSStackBlock allocated on the stack of exampleB_addBlockToArray. By the time it executes in exampleB, the the block is no longer valid, because that stack has been cleared.With ARC, the block is properly allocated on the heap as an autoreleased NSMallocBlock to begin with. 在 MRC中，block是exampleB_addBlockToArray的栈上分配一个NSStackBlock 。它在exampleB执行时，它已经被释放掉了，换一种说法：这里的block 存在栈中，所以在执行exampleB函数的exampleB_addBlockToArray(array);之后，b 变量变得无效，所以[array objectAtIndex:0]不能成功。 在 ARC中，这个 block 存在堆中类型为NSMallocBlock，当运行到[array objectAtIndex:0]，block 还没被释放，所以可以运行。 Example C123456789101112void exampleC_addBlockToArray(NSMutableArray *array) &#123; [array addObject:^&#123; printf(\"Cn\"); &#125;];&#125;void exampleC() &#123; NSMutableArray *array = [NSMutableArray array]; exampleC_addBlockToArray(array); void (^block)() = [array objectAtIndex:0]; block();&#125; Always works ExplainSince the block doesn’t capture any variables in its closure, it doesn’t need any state set up at runtime. it gets compiled as an NSGlobalBlock. It’s neither on the stack nor the heap, but part of the code segment, like any C function. This works both with and without ARC. 由于该Block没有访问任何变量，它并不需要在运行时设置的任何状态。它被编译为一个NSGlobalBlock 。它既在栈上也不再堆上,所以不管是 ARC 还是 MRC 都是可以用的。 Example D123456789101112typedef void (^dBlock)();dBlock exampleD_getBlock() &#123; char d = 'D'; return ^&#123; printf(\"%cn\", d); &#125;;&#125;void exampleD() &#123; exampleD_getBlock()();&#125; Only works in ARC ExplainThis is similar to example B. Without ARC, the block would be created on the stack of exampleD_getBlock and then immediately become invalid when that function returns. However, in this case, the error is so obvious that the compiler will fail to compile, with the error error: returning block that lives on the local stack.With ARC, the block is correctly placed on the heap as an autoreleased NSMallocBlock. 类似于example B, 在 MRC 时，block 会被创建在栈中，所以当block 返回时，马上失效。在这种情况下，错误是显而易见的，编译器无法编译成功。返回一个错误：returning block that lives on the local stack。 在 ARC 中，当自动释放池销毁，block 才失效 Example E1234567891011121314typedef void (^eBlock)();eBlock exampleE_getBlock() &#123; char e = 'E'; void (^block)() = ^&#123; printf(\"%cn\", e); &#125;; return block;&#125;void exampleE() &#123; eBlock block = exampleE_getBlock(); block();&#125; Only works in ARC ExplainThis is just like example D, except that the compiler doesn’t recognize it as an error, so this code compiles and crashes. Even worse, this particular example happens to work fine if you disable optimizations. So watch out for this working while testing and failing in production.With ARC, the block is correctly placed on the heap as an autoreleased NSMallocBlock. 类似于上一个例子，在 MRC 会造成崩溃。参考资料 Bryan Klimt — February 5th, 2013 —Objective-C Blocks Quiz","raw":null,"content":null,"categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://ganmmeng.cn/categories/iOS开发/"},{"name":"Block","slug":"iOS开发/Block","permalink":"http://ganmmeng.cn/categories/iOS开发/Block/"}],"tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://ganmmeng.cn/tags/iOS开发/"},{"name":"Block","slug":"Block","permalink":"http://ganmmeng.cn/tags/Block/"}]},{"title":"Block中级进阶（下）—— 循环引用","slug":"untitled-1465894965705","date":"2016-06-14T09:02:45.000Z","updated":"2016-06-14T09:11:40.000Z","comments":true,"path":"2016/06/14/untitled-1465894965705/","link":"","permalink":"http://ganmmeng.cn/2016/06/14/untitled-1465894965705/","excerpt":"前言Block确实很简洁，很方便，特别适合处理较为单一的回调，Block可以省去构建复杂的代理委托关系，快速实现回调的功能，但是有利也有弊，使用Block的适合时常也容易出现一些问题，例如最典型的循环引用，而这些问题也容易被大家所忽视，上篇我封装了一个BlockButton举一个实际开发中Block应用的例子，这篇我会通过它来引出循环引用的问题。 什么是循环引用之前在一篇博客中看到一段有关iOS ARC模式下循环引用问题的描述，觉得挺有意思的： ARC 下的循环引用类似于日本的 B 级恐怖片。当你刚成为苹果开发者，你或许不会关心他们的存在。直到某天你的一个 app 因内存泄露而闪退，你才突然意识到他们的存在，并且发现循环引用像幽灵一样存在于代码的各个角落。年复一年，你开始学会如何处理循环引用，检测和避免它们，但是这部片子的恐怖结局还是在那里，随时可能出现。关于循环引用的详细介绍，自己百度去，这里就不做太多解释了，就是多个对象之间相互引用，形成环状。 来看一个具体的栗子：Man类和Woman类之间相互引用 （毕竟Dog和Person 已经被用烂了，咱来点新鲜的） Man.h 12345678910111213//// Man.h// cyclingDemo//// Created by 甘萌 on 16/5/12.// Copyright © 2016年 com.BWOil. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;class Woman;@interface Man : NSObject@property (nonatomic, strong) Woman *woman;//声明一个Woman类型的变量@end Woman.h 12345678910111213//// Woman.h// cyclingDemo//// Created by 甘萌 on 16/5/12.// Copyright © 2016年 com.BWOil. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;@class Man;@interface Woman : NSObject@property (nonatomic, strong) Man *man;//声明个Man类型的变量@end 在Man.m 和 Woman.m中都实现dealloc方法 1234- (void)dealloc&#123; NSLog(@\"%s\", __func__);&#125;","keywords":null,"text":"前言Block确实很简洁，很方便，特别适合处理较为单一的回调，Block可以省去构建复杂的代理委托关系，快速实现回调的功能，但是有利也有弊，使用Block的适合时常也容易出现一些问题，例如最典型的循环引用，而这些问题也容易被大家所忽视，上篇我封装了一个BlockButton举一个实际开发中Block应用的例子，这篇我会通过它来引出循环引用的问题。 什么是循环引用之前在一篇博客中看到一段有关iOS ARC模式下循环引用问题的描述，觉得挺有意思的： ARC 下的循环引用类似于日本的 B 级恐怖片。当你刚成为苹果开发者，你或许不会关心他们的存在。直到某天你的一个 app 因内存泄露而闪退，你才突然意识到他们的存在，并且发现循环引用像幽灵一样存在于代码的各个角落。年复一年，你开始学会如何处理循环引用，检测和避免它们，但是这部片子的恐怖结局还是在那里，随时可能出现。关于循环引用的详细介绍，自己百度去，这里就不做太多解释了，就是多个对象之间相互引用，形成环状。 来看一个具体的栗子：Man类和Woman类之间相互引用 （毕竟Dog和Person 已经被用烂了，咱来点新鲜的） Man.h 12345678910111213//// Man.h// cyclingDemo//// Created by 甘萌 on 16/5/12.// Copyright © 2016年 com.BWOil. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;class Woman;@interface Man : NSObject@property (nonatomic, strong) Woman *woman;//声明一个Woman类型的变量@end Woman.h 12345678910111213//// Woman.h// cyclingDemo//// Created by 甘萌 on 16/5/12.// Copyright © 2016年 com.BWOil. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;@class Man;@interface Woman : NSObject@property (nonatomic, strong) Man *man;//声明个Man类型的变量@end 在Man.m 和 Woman.m中都实现dealloc方法 1234- (void)dealloc&#123; NSLog(@\"%s\", __func__);&#125; ViewController.h 1234567891011121314151617181920#import \"ViewController.h\"#import \"Man.h\"#import \"Woman.h\"@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //调用这个方法 在OC中方法都是作用域的，一般情况下，当方法执行结束时，方法内的局部变量都会被销毁 [self circulatorTestMethod];&#125;//测试方法- (void)circulatorTestMethod&#123; Man *man = [[Man alloc] init]; Woman *woman = [[Woman alloc] init]; //--------让他们互相持有----------// [man setWoman:woman]; [woman setMan:man]; &#125; 运行代码可以看到，当- (void)circulatorTestMethod方法执行完毕，Man 和 Woman都没有执行 dealloc方法,而当我们注释调setter方法时，Man 和 Woman则执行了 dealloc 因为Man 和 Woman互相持有，形成了一个闭环，导致Man 和 Woman都无法的到释放，造成内存泄漏，这又是一个典型的循环引用。 Block中的循环引用这里我贴出之前封装的一个BlockButton的代码来举例说明，日常开发中我们经常会封装一些控件来提高我们的编码效率，比如这个BlockButton，就省去了很多反锁的步骤，这样我们就可以直接通过Block来处理点击事件了，但是有理也有弊 BlockButton.h 1234567891011121314151617181920//// BlockButton.h// BlockButton//// Created by 甘萌 on 16/4/18.// Copyright © 2016年 com.BWOil. All rights reserved.//#import &lt;UIKit/UIKit.h&gt;typedef void(^BRButtonBlock)(void);@interface BlockButton : UIButton@property (nonatomic, copy) BRButtonBlock touchBlock;- (void)gm_addActionWithControlEvents:(UIControlEvents)controlEvents touchBlock:(BRButtonBlock)touchBlock;@end BlockButton.m 123456789101112131415161718192021222324252627282930313233343536373839404142//// BlockButton.m// BlockButton//// Created by 甘萌 on 16/4/18.// Copyright © 2016年 com.BWOil. All rights reserved.//#import \"BlockButton.h\"@implementation BlockButton- (instancetype)initWithFrame:(CGRect)frame&#123; if (self = [super initWithFrame:frame]) &#123; &#125; return self;&#125;- (void)gm_addActionWithControlEvents:(UIControlEvents)controlEvents touchBlock:(BRButtonBlock)touchBlock&#123; self.touchBlock = touchBlock; [self addTarget:self action:@selector(touchAction:) forControlEvents:controlEvents]; &#125;- (void)touchAction:(BlockButton *)sender&#123; //事件处 if (self.touchBlock) &#123; self.touchBlock(); &#125;&#125;- (void)dealloc&#123; NSLog(@\"%s\", __func__);&#125;@end 我们把这个封装好的按钮运用到实际的项目开发中去，这里我们假定一个需求，在ControllerA中有一个按钮，点击按钮Modal到ControllerB,ControllerB里面有一个十分占内存的MapView ControllerA 123456789101112131415161718192021222324252627282930313233343536373839404142434445//// ViewController.m// BlockButton//// Created by 甘萌 on 16/4/18.// Copyright © 2016年 com.BWOil. All rights reserved.//#import \"ViewController.h\"#import \"ViewController2.h\"#import \"BlockButton.h\"@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. self.view.backgroundColor = [UIColor redColor]; BlockButton *blockButton = [[BlockButton alloc] initWithFrame:CGRectMake(30, 40, 100, 25)]; [blockButton gm_addActionWithControlEvents:UIControlEventTouchUpInside touchBlock:^&#123; ViewController2 *vc2 = [[ViewController2 alloc] init]; [self presentViewController:vc2 animated:YES completion:nil]; &#125;]; blockButton.backgroundColor = [UIColor lightGrayColor]; [self.view addSubview:blockButton]; &#125;- (void)dealloc&#123; NSLog(@\"%s\", __func__);&#125;@end ControllerB 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//// ViewController2.m// BlockButton//// Created by 甘萌 on 16/4/19.// Copyright © 2016年 com.BWOil. All rights reserved.//#import &lt;MapKit/MapKit.h&gt;#import \"ViewController2.h\"#import \"BlockButton.h\"@interface ViewController2 ()@end@implementation ViewController2- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. self.view.backgroundColor = [UIColor greenColor]; MKMapView *mapView = [[MKMapView alloc] initWithFrame:self.view.bounds]; [self.view addSubview:mapView]; BlockButton *blockButton = [[BlockButton alloc] initWithFrame:CGRectMake(30, 40, 100, 25)]; blockButton.backgroundColor = [UIColor lightGrayColor];//Dissmiss回去 [blockButton gm_addActionWithControlEvents:UIControlEventTouchUpInside touchBlock:^&#123; [self dismissViewControllerAnimated:YES completion:nil]; &#125;]; [self.view addSubview:blockButton]; &#125;- (void)dealloc&#123; NSLog(@\"%s\", __func__);&#125;@end 运行项目，点击按钮Modal 到B控制器，再从B控制器Dissmiss回去，看似一切正常但是反复这样操作几次我们会发现程序的内存已经占用到惊人的**700M**，并且所以的dealloc方法里的打印都没有被执行，也就是说，当我Modal到B在Dismiss回来的时候B并没有被销毁，B中的MapView占用的大量内存没有得到释放，这个问题十分严重！！！ 为什么会这样呢，通过Xcode中的instruments检测内存也没有任何异常其实我们的程序已经处于一个循环引用的状态中，它不是两个对象之间的，而是多个对象之间的循环引用，在B中，在Block直接使用了self来调用Dissmiss方法，B被BlockButton中的Block持有，而Block又被BlockButton所持有，BlockButton又被Self.view持有，self.view被self持有，前面说到的，Self被Block持有，这样就形成了一个闭环，造成了循环引用。想要打破我们就要用到__weak typeof(self) weakSelf = self;来声明一个弱引用的self在Block中调用，这样就可以打破之前所形成的闭环。从而解决循环引用的问题。这也是为什么在Block要使用weakSelf的原因。 在Block中使用weakSelf 也会遇到一些奇葩问题，在下一节中我会详细讲解。 P.S 最近事情比较多，没时间写东西，本节的一些技术点讲的也比较粗糙，我会抽空完善。","raw":null,"content":null,"categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://ganmmeng.cn/categories/iOS开发/"},{"name":"Block","slug":"iOS开发/Block","permalink":"http://ganmmeng.cn/categories/iOS开发/Block/"}],"tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://ganmmeng.cn/tags/iOS开发/"},{"name":"Block","slug":"Block","permalink":"http://ganmmeng.cn/tags/Block/"}]},{"title":"[转]runtime从入门到放弃","slug":"untitled-1463103388379","date":"2016-05-13T01:36:28.000Z","updated":"2016-05-13T01:46:53.000Z","comments":true,"path":"2016/05/13/untitled-1463103388379/","link":"","permalink":"http://ganmmeng.cn/2016/05/13/untitled-1463103388379/","excerpt":"本文为转载原文地址： 孝平的博客 —— runtime从入门到放弃 GG 背景本篇不适应runtime学习，也不涉及runtime长篇大论的理论知识。本篇只是想让你适当的学会放手。而所谓的入门到放弃中的入门则是一些runtime常用apis的认识和使用场景（笔者工作总结）。而所谓的放弃就是不要太过于执着runtime，其实它并没有你想象中的那么好。 来嗨起来现在就让我们开始来旅游runtime的世界吧~！","keywords":null,"text":"本文为转载原文地址： 孝平的博客 —— runtime从入门到放弃 GG 背景本篇不适应runtime学习，也不涉及runtime长篇大论的理论知识。本篇只是想让你适当的学会放手。而所谓的入门到放弃中的入门则是一些runtime常用apis的认识和使用场景（笔者工作总结）。而所谓的放弃就是不要太过于执着runtime，其实它并没有你想象中的那么好。 来嗨起来现在就让我们开始来旅游runtime的世界吧~！ 关联objc_setAssociatedObject 关联，懂点runtime或者不懂runtime的应该都知道这个家伙吧。再或者在分类里也应该见过不少了吧。不讲它用法，只分享笔者经历。 关联的用处一般是用来在分类里定义属性，分别在属性的set和get方法里存放或者获取属性的值。当然还有一个用处也比较实用，则是强引用自己，并且不要释放。强引用自己？嗯哼？怎么有一点晕晕的。好吧，举个列子。需求（可忽略）：比如你有一个ZXPAAA的class，然后ZXPAAA里有show和dismiss方法，并且还有一个delegate回调。然后你还有一个ZXPBBB的class并且有一个函数叫test。现在test函数里有一个局部自动变量ZXPAAA的实例，并且调用ZXPAAA的show方法来弹出一个视图。那么问题来了，这时候你在ZXPBBB的test方法里设置ZXPAAA的delegate为self（self=ZXPBBB）的时候，因为ZXPAAA是局部自动变量，所以在test函数执行完之前，函数内部的ZXPAAA实例变量的引用计数会减一，由于你只是实例化了一下，引用计数为一，然后在减一，故此，此变量会释放，然后在这时候你遵守的ZXPAAA的delegate方法永远不会回调。解决： 那么这时候你就可以在ZXPAAA里的show方法用objc_setAssociatedObject来关联自己并设置retain引用+1。让self不会释放，代码如下：12//ZXPAAA的show 方法里，关联自己，会引用计数+1objc_setAssociatedObject(self, key, self, OBJC_ASSOCIATION_RETAIN_NONATOMIC);目前为止确实是解决了对象自动释放的问题，可问题是对象一直存在呀。内存泄露了尼。不用怕，我们在ZXPAAA的dismiss 方法里释放关联就行了。代码如下：12//ZXPAAA的dismiss 方法里，从关联里移除，设置为nil,会引用计数-1objc_setAssociatedObject(self, key, nil, OBJC_ASSOCIATION_ASSIGN);之前简单封装了一个pickerView工具类里面有用到类似场景，点此进行传输进行查看。 获取class的所有方法（包含私有）核心方法是class_copyMethodList，直接贴代码：12345678910uint count;//返回值是一个Method指针 Method *methodList = class_copyMethodList([NSObject class], &amp;count); for ( int i = 0 ; i &lt; count; i++) &#123; NSLog(@”%@”,NSStringFromSelector(method_getName(methodList[i]))); &#125; //释放 free(methodList);以上这串代码，看似很牛逼。。其实用一句话来形容就是just so so而已。其实最主要的是并没有任何一点实际用处。就算知道了很多私有方法，你想去完美的运用它也需要很多时间成本，而且app store还不会给你上线(企业发布除外)。PS：更多用法直接去查看.h文件即可。 获取class的所有变量（包含私有）核心方法是class_copyIvarList，直接贴代码：1234567891011uint count; //返回值是一个Ivar指针 Ivar *ivarList = class_copyIvarList([UIViewController class], &amp;count); for ( int i = 0 ; i &lt; count; i++) &#123; NSLog(@”%s”,ivar_getName(ivarList[i])); &#125; //释放 free(ivarList); 获取变量和获取方法同理，然并卵，但作为兴趣研究研究的话，还是可以玩玩的。在工程里的实际用处也并不大。PS：更多用法直接去查看.h文件即可。方法替换API为method_exchangeImplementations，交换两个方法的实现，一般用来进行黑魔法调试。虽然也可以用来实现AOP切面编程，but…工程里千万慎用，千万慎用，千万慎用。重要的事情说三遍，至于为什么，原因很简单，不好维护，出了错都不知道飞哪儿去了。而要实现方法切面可使用开源的Aspects。PS: 所谓的黑魔法调试，比如替换init方法，并打印一句话，方便我们知道哪些class被初始化，而AOP切面编程的概念网上也有很多，随意百度一下即可。其他其他还有很多，比如objc_copyClassList获取所有class，method_setImplementation给方法重置一个IMP等等。关于runtime的API有点太多了，就不一一列举了。当然关于runtime知识点远不止这些api这么简单，比如消息转发，重定向等等。写在最后but…. runtime有这么多的api，到底有什么用？答案是并没什么卵用，对，虽然没卵用，但还是很重要，不要问我为什么，就因为它是OC底层，核心。作为一位iOSer，了解这些基础是必须的，起码装逼也有了资本。再退一万步来讲，对于面试，这些也会派上用场。不过对于工作中，确实没啥太大的用处，但是如果写框架的话，用处还是特别大，而且作为程序员也不能一直停留在应用层层面。当然，在工作中用的并不怎么多，但是，还是必须要学的。而标题所谓的放弃的寓意是，让你不要太过于纠结runtime到底有什么用。因为也有很多新人问过笔者runtime到底能做什么….况且现在关于这方面的资料也不多。资料查来查去无非就是消息转发，重定向还有那几个获取变量、方法等几个常用的API而已。当然，对于runtime笔者也连门都没有入。。在此笔者建议新人们一直捉摸不透runtime到底能做什么，倒不如花花时间去研究一下GCD，core foundation等。以上纯属笔者个人给新人的一些建议以及一些runtime肤浅的用法。欢迎吐槽，请勿喷贴。。。转载请注明原文出处","raw":null,"content":null,"categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://ganmmeng.cn/categories/iOS开发/"},{"name":"Runtime","slug":"iOS开发/Runtime","permalink":"http://ganmmeng.cn/categories/iOS开发/Runtime/"}],"tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://ganmmeng.cn/tags/iOS开发/"},{"name":"Runtime","slug":"Runtime","permalink":"http://ganmmeng.cn/tags/Runtime/"}]},{"title":"Block中级进阶（中）——Block实际应用","slug":"untitled-1463040521846","date":"2016-05-12T08:08:41.000Z","updated":"2016-05-12T08:15:35.000Z","comments":true,"path":"2016/05/12/untitled-1463040521846/","link":"","permalink":"http://ganmmeng.cn/2016/05/12/untitled-1463040521846/","excerpt":"前言Block确实很简洁，很方便，特别适合处理较为单一的回调，Block可以省去构建复杂的代理委托关系，快速实现回调的功能，但是有利也有弊，使用Block的适合时常也容易出现一些问题，例如最典型的循环引用，而这些问题也容易被大家所忽视，这篇我会用一个例子引出这一系列的问题 Block的的应用 前面我已经介绍了Block的一些简单的用法，但是在实际开发中，我们并不那样去使用它，一半来说Block大多用于对象与对象之间的通信 BlockButton的封装 下面我就举个栗子：我们来自定义一个Block按钮，以便省去添加事件的繁琐操作 1.首先我们创建一个继承于UIButto的Class 叫做 BlcokButton2.定义好Block类型，创建Block对象 123456789101112131415161718//// BlockButton.h// blockDemo//// Created by GANMENG on 16/5/12.// Copyright © 2016年 BrightOil. All rights reserved.//#import &lt;UIKit/UIKit.h&gt;//定义Block类型typedef void(^ActionBlock)(UIButton *);;@interface BlockButton : UIButton//创建一个Block对象，block创建后内存是分配在栈上的，调用copy方法，会将block从栈上移到堆上。当block声明为全局变量时，我们应该调用block的copy方法。@property (nonatomic, copy) ActionBlock actionBlock;@end","keywords":null,"text":"前言Block确实很简洁，很方便，特别适合处理较为单一的回调，Block可以省去构建复杂的代理委托关系，快速实现回调的功能，但是有利也有弊，使用Block的适合时常也容易出现一些问题，例如最典型的循环引用，而这些问题也容易被大家所忽视，这篇我会用一个例子引出这一系列的问题 Block的的应用 前面我已经介绍了Block的一些简单的用法，但是在实际开发中，我们并不那样去使用它，一半来说Block大多用于对象与对象之间的通信 BlockButton的封装 下面我就举个栗子：我们来自定义一个Block按钮，以便省去添加事件的繁琐操作 1.首先我们创建一个继承于UIButto的Class 叫做 BlcokButton2.定义好Block类型，创建Block对象 123456789101112131415161718//// BlockButton.h// blockDemo//// Created by GANMENG on 16/5/12.// Copyright © 2016年 BrightOil. All rights reserved.//#import &lt;UIKit/UIKit.h&gt;//定义Block类型typedef void(^ActionBlock)(UIButton *);;@interface BlockButton : UIButton//创建一个Block对象，block创建后内存是分配在栈上的，调用copy方法，会将block从栈上移到堆上。当block声明为全局变量时，我们应该调用block的copy方法。@property (nonatomic, copy) ActionBlock actionBlock;@end 在.m文件中给Block添加事件，并且通过ActionBlock回调 12345678910111213141516171819202122232425#import \"BlockButton.h\"@implementation BlockButton- (id)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; //给button添加事件 [self addTarget:self action:@selector(action:) forControlEvents:UIControlEventTouchUpInside]; &#125; return self;&#125;#pragma mark -#pragma mark - Action- (void)action:(UIButton *)sender&#123; //这里一定要判断Block是否为有值的，不然会造成野指针异常。就像是用代理对象回调的时候也要判断delegate 是否有值并且 delegate是否响应了协议里的方法。p.s. 要养成好的编码习惯 if (self.actionBlock) &#123; self.actionBlock(sender); &#125;&#125;@end 就这两个步骤，我们的BlockButton 就封装完了，我们只需要到ViewController中去使用就可以了 123456789101112131415#import \"ViewController.h\"#import \"BlockButton.h\"@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; BlockButton *blockBtn = [[BlockButton alloc] initWithFrame:CGRectMake(100, 100, 100, 35)]; [blockBtn setBackgroundColor:[UIColor redColor]]; blockBtn.actionBlock = ^(UIButton *sender)&#123; NSLog(@\"点击了BlockButton\"); &#125;; [self.view addSubview:blockBtn];&#125;/*---------输出结果---------*/@\"prints: blockDemo[6107:1144064] 点击了BlockButton\" BlockButton的优化 写到这里，有些同学可能会有疑问了，BlockButton只能支持TouchUpInside一种事件类型吗? 难道如果其他事件也想用Block来实现回调还要定义那么多不同的BlockButton吗？ 其实我们只需要稍微修改一下上面的代码就可以让BlockButton可以处理各种事件类型前面有提到过，Block是一个iOS中的对象类型，它可以在方法中作为参数传递 12345678910#import &lt;UIKit/UIKit.h&gt;//定义Block类型typedef void(^ActionBlock)(UIButton *sender);;@interface BlockButton : UIButton//新增的方法，可以传递事件，和Block- (void)gm_addActionForControlEvents:(UIControlEvents)controlEvents callBackWithActionBlock:(ActionBlock)actionBlock;@end 实现这个方法，给BlockButton所持有的actionBlock赋值，添加事件，block回调 1234567891011121314151617181920212223242526272829#import \"BlockButton.h\"@interface BlockButton ()//创建一个Block对象，block创建后内存是分配在栈上的，调用copy方法，会将block从栈上移到堆上。当block声明为全局变量时，我们应该调用block的copy方法。@property (nonatomic, copy) ActionBlock actionBlock;@end@implementation BlockButton#pragma mark -#pragma mark - PublicMethod- (void)gm_addActionForControlEvents:(UIControlEvents)controlEvents callBackWithActionBlock:(ActionBlock)actionBlock&#123; //将公用方法传递过来的block对象赋值给 self.actionBlock = actionBlock; [self addTarget:self action:@selector(action:) forControlEvents:controlEvents];&#125;#pragma mark -#pragma mark - Action- (void)action:(UIButton *)sender&#123; //这里一定要判断Block是否为有值的，不然会造成野指针异常。就像是用代理对象回调的时候也要判断delegate 是否有值并且 delegate是否响应了协议里的方法。p.s. 要养成好的编码习惯 if (self.actionBlock) &#123; self.actionBlock(sender); &#125;&#125;@end 这样我们的blockButton就可以处理各种不同的情况了，而且代码也接近系统的api，用起来十分顺手！😊在ViewController中来使用 12345678910111213141516171819202122#import \"ViewController.h\"#import \"BlockButton.h\"@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; BlockButton *blockBtn = [[BlockButton alloc] initWithFrame:CGRectMake(100, 100, 100, 35)]; [blockBtn setBackgroundColor:[UIColor redColor]]; [blockBtn gm_addActionForControlEvents:UIControlEventTouchUpInside callBackWithActionBlock:^(UIButton *sender) &#123; NSLog(@\"点击了BlockButton\"); &#125;]; [self.view addSubview:blockBtn];&#125;/*---------输出结果---------*/@\"prints: blockDemo[6107:1144064] 点击了BlockButton\" 到这里BlockButton也差不多封装完了，当然你也可以通过使用分类来实现。p.s. 这一篇简单的介绍了Block在实际开发中的回调用法，下一篇我会详细讲解循环引用。❤️❤️❤️❤️","raw":null,"content":null,"categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://ganmmeng.cn/categories/iOS开发/"},{"name":"Block","slug":"iOS开发/Block","permalink":"http://ganmmeng.cn/categories/iOS开发/Block/"}],"tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://ganmmeng.cn/tags/iOS开发/"},{"name":"Block","slug":"Block","permalink":"http://ganmmeng.cn/tags/Block/"}]},{"title":"Block中级进阶（上）","slug":"block-2","date":"2016-05-11T01:48:32.000Z","updated":"2016-05-12T08:31:16.000Z","comments":true,"path":"2016/05/11/block-2/","link":"","permalink":"http://ganmmeng.cn/2016/05/11/block-2/","excerpt":"前言前段时间在公司iOS小组组织了技术分享会，由浅入深的剖析了Block，在这里记录下来，温故而知新 Block和变量 变量按作用域又分有全局变量和局部变量 block代码块内可以引用这两种变量，但是有不同的管理机制 代码说明 在Block里 可以读取变量，但是默认情况是下不能修改变量的值的 12345678int a = 100;void (^myBlock)(int) = ^(int b) &#123; a = 10000; //这里会报错， NSLog(@\"%d %d\\n\", a, b);&#125;;myBlock(110); //调用Block/*---------输出结果---------*/@\"prints: 100 110\"","keywords":null,"text":"前言前段时间在公司iOS小组组织了技术分享会，由浅入深的剖析了Block，在这里记录下来，温故而知新 Block和变量 变量按作用域又分有全局变量和局部变量 block代码块内可以引用这两种变量，但是有不同的管理机制 代码说明 在Block里 可以读取变量，但是默认情况是下不能修改变量的值的 12345678int a = 100;void (^myBlock)(int) = ^(int b) &#123; a = 10000; //这里会报错， NSLog(@\"%d %d\\n\", a, b);&#125;;myBlock(110); //调用Block/*---------输出结果---------*/@\"prints: 100 110\" Block 能读取变量的原理是 copy了一份变量的值,也有说是Block将外部变量以常量的形式存进去。所以在 Block 定义之后修改变量的值，再调用 Block，值依旧是修改前的。换句话说，定义好 Block 之后，修改变量值对 Block 无效。 12345678910int a = 100;void (^myBlock)(int) = ^(int b) &#123; a = 123; //这里会报错， NSLog(@\"%d %d\\n\", a, b);&#125;;a = 10000;//在Block定义后修改a的值myBlock(110); //调用Block/*---------输出结果---------*/@\"prints: 100 110\" __block关键字的用处 如果需要对在block里修改外部定义的变量，那么需要对这个变量前添加一个__block修饰。 12345678__block int a = 100; //在变量前添加__blockvoid (^myBlock)(int) = ^(int b) &#123; a = 10000; //这里不会报错， NSLog(@\"%d %d\\n\", a, b);&#125;;myBlock(110); //调用Block/*---------输出结果---------*/@\"prints: 10000 110\" 如果需要在block定义外面修改变量的值，变量的修改都会影响 block 内部对这个变量的使用，换句话说，block 对变量不再是简单的值复制，而是动态的&quot;监听&quot;值的变化，然后在调用的时候读取变量修改后的值，也需要对这个变量添加一个__block修饰。 12345678910__block int a = 100; //在变量前添加__blockvoid (^myBlock)(int) = ^(int b) &#123; a = 123; //这里会报错， NSLog(@\"%d %d\\n\", a, b);&#125;;a = 10000;//在Block定义后修改a的值myBlock(110); //调用Block 会「动态」识别外部变量的变化，输出10000也就是a最修改后的值/*---------输出结果---------*/@\"prints: 10000 110\" 最后还要注意区别变量和指针所指向的变量 123456789int a= 123;NSMutableString *str = [NSMutableString stringWithFormat:@\"Hello\"];void (^printStr)() = ^() &#123; [str appendString:@\"World\"]; NSLog(@\"%@\",str);&#125;;printStr();/*---------输出结果---------*/@\"prints: HelloWorld\" 为什么在block里面修改string [str appendString:@”World”];不报错是因为str 是指向@”Hello”的函数指针，[str appendString:@”World”];并不是修改 str 所存储的值，本质上是 str 向@”Hello”发送了一条appendString 消息，然后再更改@”Hello”为@”HelloWorld”，而 str 存储的指向@”HelloWorld”对象的指针没有发生变化。所以， block本质上是不能修改变量存储的值，但是消息分发确依旧有效。","raw":null,"content":null,"categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://ganmmeng.cn/categories/iOS开发/"},{"name":"Block","slug":"iOS开发/Block","permalink":"http://ganmmeng.cn/categories/iOS开发/Block/"}],"tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://ganmmeng.cn/tags/iOS开发/"},{"name":"Block","slug":"Block","permalink":"http://ganmmeng.cn/tags/Block/"}]},{"title":"Block 初识","slug":"Block-1","date":"2016-05-09T01:40:41.000Z","updated":"2016-05-12T08:17:03.000Z","comments":true,"path":"2016/05/09/Block-1/","link":"","permalink":"http://ganmmeng.cn/2016/05/09/Block-1/","excerpt":"前言前段时间在公司iOS小组组织了技术分享会，由浅入深的剖析了Block，在这里记录下来，温故而知新 什么是Block Block是iOS4之后新增的一种语法结构，也称之为“闭包（closure）” Block是iOS中一种比较特殊的数据类型 是一个能工作的代码单元，可以在任何需要的时候被执行 本质是轻量级的匿名函数，可以作为其他函数的参数或者返回值。 Block是苹果官方特别推荐使用的数据类型, 应用场景比较广泛 动画 多线程 集合遍历 网络请求回调 新版的AlertController等等等… Block的作用 用来保存某一段代码, 可以在恰当的时间再取出来调用 功能类似于函数和方法","keywords":null,"text":"前言前段时间在公司iOS小组组织了技术分享会，由浅入深的剖析了Block，在这里记录下来，温故而知新 什么是Block Block是iOS4之后新增的一种语法结构，也称之为“闭包（closure）” Block是iOS中一种比较特殊的数据类型 是一个能工作的代码单元，可以在任何需要的时候被执行 本质是轻量级的匿名函数，可以作为其他函数的参数或者返回值。 Block是苹果官方特别推荐使用的数据类型, 应用场景比较广泛 动画 多线程 集合遍历 网络请求回调 新版的AlertController等等等… Block的作用 用来保存某一段代码, 可以在恰当的时间再取出来调用 功能类似于函数和方法 Block的格式直接定义Block变量 Block 的定义格式1返回值类型 (^block变量名)(形参列表) = ^(形参列表) &#123;//do something&#125;; 1.block最简单形式（无形参无返回值）123456void (^block参数名)() = ^&#123;代码块...&#125;;例如:void (^myBlock)() = ^&#123; NSLog(@&quot;doSomething&quot;);&#125;; 2.block中级进阶形式（有形参无返回值）12345678void (^block名称)(参数列表) = ^ (参数列表) &#123; // 代码实现 &#125;;例如:void (^myBlock)(int) = ^(int a)&#123; NSLog(@&quot;a = %d&quot;, a);&#125;; 3.block高级进阶形式（有形参有返回值）12345678返回类型 (^block名称)(参数列表) = ^ 返回类型 (参数列表) &#123; // 代码实现...&#125;;例如:int (^myBlock)(int, int) = ^(int a, int b)&#123; return a + b;&#125;; 调用Block1block变量名(参数); 定义Block的类型12345typedef 返回值 (^Block类型名)(参数);例如:typedef int (^MyFirstBlock)(int); 使用自定义Block类型声明Block对象1234567891011类型名 变量名 = (^ 参数)&#123; retrun result;&#125;;例如：MyFirstBlock myBlock = ^(int a)&#123; return a * a;&#125;; 未完待续","raw":null,"content":null,"categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://ganmmeng.cn/categories/iOS开发/"},{"name":"Block","slug":"iOS开发/Block","permalink":"http://ganmmeng.cn/categories/iOS开发/Block/"}],"tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://ganmmeng.cn/tags/iOS开发/"},{"name":"Block","slug":"Block","permalink":"http://ganmmeng.cn/tags/Block/"}]},{"title":"建站小记","slug":"untitled-1462496926972","date":"2016-05-06T01:08:46.000Z","updated":"2016-05-09T05:12:45.000Z","comments":true,"path":"2016/05/06/untitled-1462496926972/","link":"","permalink":"http://ganmmeng.cn/2016/05/06/untitled-1462496926972/","excerpt":"前言从小就喜欢玩电脑，一直有一个梦想就是能有一个自己的网站，觉得这是一个很酷的事情，所以经过一个星期的研究和学习，总于搭建了一个属于我&gt; 自己的博客，是不是很酷！？我本来就是一个不善言表的人，虽然博客是顺利的搭建出来了，但是内容嘛。。所以我决定每周都一定要来更新我的博客，可能是技术也可能是其他的文字内容和个人感悟，以此来提升自己也希望能帮助到大家～加油感觉萌！ 关于github1.我的开发环境是OS X，Mac是自带git的所以也免去了配置git的步骤，我的这个博客其实就是使用github Pages，然后配合目前最好用的博客框架—hexo搭建的，hexo是出自一个台湾大学生之手，比起其他的jekll等更好用，而且官方文档也支持中文，很容易看懂，我推荐一篇关于如何搭建个人博客的文章，虽然很容易，但是搭建的过程中也遇到了很多坑。—-&gt;文章传送门 2.最近加了一个github iOS 大牛建的iOS高端开发群，我发现自己真的很菜（之前还有点沾沾自喜觉得该会的都会了）程序猿就是这样，学无止境，你不进步就会慢慢被淘汰，我要学的还有很多多，我今年的目标其实很早就定下来了，例如掌握swift，入门H5，学习React Native，可是现实情况就是几乎还没启动！！！我的计划过开源一些框架，当至少目前为止我的github上还是空空如也！！！我的拖延症是时候治治了！今天写这篇文子也是要给自己提个醒，该醒悟了，什么英雄联盟，手机游戏等等都是麻痹自己的，年纪不小了，已经不是玩那些东西的年纪了！","keywords":null,"text":"前言从小就喜欢玩电脑，一直有一个梦想就是能有一个自己的网站，觉得这是一个很酷的事情，所以经过一个星期的研究和学习，总于搭建了一个属于我&gt; 自己的博客，是不是很酷！？我本来就是一个不善言表的人，虽然博客是顺利的搭建出来了，但是内容嘛。。所以我决定每周都一定要来更新我的博客，可能是技术也可能是其他的文字内容和个人感悟，以此来提升自己也希望能帮助到大家～加油感觉萌！ 关于github1.我的开发环境是OS X，Mac是自带git的所以也免去了配置git的步骤，我的这个博客其实就是使用github Pages，然后配合目前最好用的博客框架—hexo搭建的，hexo是出自一个台湾大学生之手，比起其他的jekll等更好用，而且官方文档也支持中文，很容易看懂，我推荐一篇关于如何搭建个人博客的文章，虽然很容易，但是搭建的过程中也遇到了很多坑。—-&gt;文章传送门 2.最近加了一个github iOS 大牛建的iOS高端开发群，我发现自己真的很菜（之前还有点沾沾自喜觉得该会的都会了）程序猿就是这样，学无止境，你不进步就会慢慢被淘汰，我要学的还有很多多，我今年的目标其实很早就定下来了，例如掌握swift，入门H5，学习React Native，可是现实情况就是几乎还没启动！！！我的计划过开源一些框架，当至少目前为止我的github上还是空空如也！！！我的拖延症是时候治治了！今天写这篇文子也是要给自己提个醒，该醒悟了，什么英雄联盟，手机游戏等等都是麻痹自己的，年纪不小了，已经不是玩那些东西的年纪了！ 关于拖延症以前还没觉得，之前是在一家外包公司干了一年多，天天任务排的满满的，晚上回去有的时候还会为第二天的工作做写准备，现在的这家公司的节奏和之前完全不一样，没有加班，任务比较轻松，每天上班把该完成的做完基本上就可以逛逛论坛，看看大牛的博客等等，但是回到家里之后就再也没有了从前的那种激情（躺在床上玩手机游戏，看泡沫剧等等）虽然也有想过要去学习，比如我会在心里说该看看斯坦福的iOS视频了，该学swift了，该看新买的有关H5的书了，但是每次脑海中都有一个声音：过几天在看，反正时间还多，公司事情也不忙，就这样本来计划15年看完的斯坦福公开课至今都没看完，我在TED的视频中看到有关拖延症的（TED拖延症视频），OMG这不是和我的情况类似吗。。，更可怕的是这还是没有期限的拖延症。p.s. 难道我的大脑里真的有个猴子在掌舵吗。。拖延症太可怕了！！！ 关于hexohexo的安装需要两个前提条件：安装git和nodejs。参见hexo官方文档。nodejs有Mac下的安装包下载地址，安装的时候注意添加node环境变量，然后再用npm install -g hexo一句代码就能安装好了。如果报错那就是权限问题在前面加上sudo就可以了，像这样sudo npm install -g.接下来，我还要谢谢锤神，是他耐心的解答我遇到的各种问题，十分感谢！ 关于ganmmeng.cn我是是一个选择恐惧症患者，这个域名是我话了一上午时间才确定的，毕竟是我人生中第一个域名。。虽然才花了29块钱 ＝＝。。叫ganmmeng是因为我的小名就叫萌萌，我是男的！还有我姓甘，最后我的第一个域名就这样诞生了！当然这些都不是重点，只有坚持写出好的东西，分享自己的经验和心得，这个博客才能有更多的意义吧。 关于我我就是一个普通的程序猿，有一些情怀和理想，经历过成功与失败，但还是热爱我的生活和事业，希望尽自己的努力去生活的快乐。最后放上一段前几天看到的鸡汤 “你20几岁的努力与沉淀，是为30岁以后的优质生活打下基础。现在的我，可以理直气壮的因为贫穷这件事来不断督促自己努力进步。我知道，这辈子也许无法大富大贵，但只要平安健康也是知足。至少，我一直处于努力状态中，奔跑的姿态会告诉我并没有辜负时间” 为自己加油！ 2016.4.29 Gan","raw":null,"content":null,"categories":[{"name":"blog","slug":"blog","permalink":"http://ganmmeng.cn/categories/blog/"}],"tags":[{"name":"杂","slug":"杂","permalink":"http://ganmmeng.cn/tags/杂/"},{"name":"blog","slug":"blog","permalink":"http://ganmmeng.cn/tags/blog/"}]},{"title":"hexo-hey","slug":"untitled-1461912646136","date":"2016-04-29T06:50:46.000Z","updated":"2016-05-09T05:05:43.000Z","comments":true,"path":"2016/04/29/untitled-1461912646136/","link":"","permalink":"http://ganmmeng.cn/2016/04/29/untitled-1461912646136/","excerpt":"Hey hexo 真的很强大an admin plugin for hexo, support hexo v3.xbuilt with gulp + babel + webpackusing es6 + angular + materail + jwt Demohttp://nihgwu.github.io/hexo-hey/username: hexopassowrd: hey About client framework: angular dashboard ui: material authentication: jwt markdown parser: marked markdown style: github-markdown-css markdown editor: codemirror","keywords":null,"text":"Hey hexo 真的很强大an admin plugin for hexo, support hexo v3.xbuilt with gulp + babel + webpackusing es6 + angular + materail + jwt Demohttp://nihgwu.github.io/hexo-hey/username: hexopassowrd: hey About client framework: angular dashboard ui: material authentication: jwt markdown parser: marked markdown style: github-markdown-css markdown editor: codemirror Usage1. install hexo-hey1npm install hexo-hey --save 2. add a admin config section to _config.yml:1234567# Adminadmin: name: hexo password: hey secret: hey hexo expire: 60*1 # cors: http://localhost:3000 cors is optional if you want serve your client in another place(CDN for example) 3. serve hexo1hexo serve then visit http://localhost:4000/admin , and login with the account set in previous step","raw":null,"content":null,"categories":[{"name":"hexo","slug":"hexo","permalink":"http://ganmmeng.cn/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://ganmmeng.cn/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-04-29T04:39:04.000Z","updated":"2016-05-09T05:05:31.000Z","comments":true,"path":"2016/04/29/hello-world/","link":"","permalink":"http://ganmmeng.cn/2016/04/29/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing","keywords":null,"text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","raw":null,"content":null,"categories":[{"name":"ALL","slug":"ALL","permalink":"http://ganmmeng.cn/categories/ALL/"}],"tags":[{"name":"杂","slug":"杂","permalink":"http://ganmmeng.cn/tags/杂/"}]}]}