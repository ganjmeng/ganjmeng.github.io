{"meta":{"title":"感觉萌的Blog","subtitle":"欲罢不能，想想都有点小激动。","description":"欲罢不能，想想都有点小激动。","author":"Gan Meng","url":"http://ganmmeng.cn"},"pages":[{"title":"about","date":"2016-04-29T08:51:57.000Z","updated":"2016-05-06T02:05:06.000Z","comments":true,"path":"about/index.html","permalink":"http://ganmmeng.cn/about/index.html","excerpt":"","keywords":null,"text":"DillingerDillinger is a cloud-enabled, mobile-ready, offline-storage, AngularJS powered HTML5 Markdown editor. Type some Markdown on the left See HTML in the right Magic Markdown is a lightweight markup language based on the formatting conventions that people naturally use in email. As John Gruber writes on the Markdown site The overriding design goal for Markdown’sformatting syntax is to make it as readableas possible. The idea is that aMarkdown-formatted document should bepublishable as-is, as plain text, withoutlooking like it’s been marked up with tagsor formatting instructions. This text you see here is actually written in Markdown! To get a feel for Markdown’s syntax, type some text into the left window and watch the results in the right. Version3.2.7 TechDillinger uses a number of open source projects to work properly: AngularJS - HTML enhanced for web apps! Ace Editor - awesome web-based text editor markdown-it - Markdown parser done right. Fast and easy to extend. Twitter Bootstrap - great UI boilerplate for modern web apps node.js - evented I/O for the backend Express - fast node.js network app framework @tjholowaychuk Gulp - the streaming build system keymaster.js - awesome keyboard handler lib by @thomasfuchs jQuery - duh And of course Dillinger itself is open source with a public repository on GitHub. InstallationDillinger requires Node.js v4+ to run. You need Gulp installed globally: 1$ npm i -g gulp 12345$ git clone [git-repo-url] dillinger$ cd dillinger$ npm i -d$ gulp build --prod$ NODE_ENV=production node app PluginsDillinger is currently extended with the following plugins Dropbox Github Google Drive OneDrive Readmes, how to use them in your own application can be found here: plugins/dropbox/README.md plugins/github/README.md plugins/googledrive/README.md plugins/onedrive/README.md DevelopmentWant to contribute? Great! Dillinger uses Gulp + Webpack for fast developing.Make a change in your file and instantanously see your updates! Open your favorite Terminal and run these commands. First Tab:1$ node app Second Tab:1$ gulp watch (optional) Third:1$ karma start DockerDillinger is very easy to install and deploy in a Docker container. By default, the Docker will expose port 80, so change this within the Dockerfile if necessary. When ready, simply use the Dockerfile to build the image. 12cd dillingerdocker build -t &lt;youruser&gt;/dillinger:latest . This will create the dillinger image and pull in the necessary dependencies. Once done, run the Docker and map the port to whatever you wish on your host. In this example, we simply map port 80 of the host to port 80 of the Docker (or whatever port was exposed in the Dockerfile): 1docker run -d -p 80:80 --restart=\"always\" &lt;youruser&gt;/dillinger:latest Verify the deployment by navigating to your server address in your preferred browser. N|Solid and NGINXMore details coming soon. docker-compose.ymlChange the path for the nginx conf mounting path to your full path, not mine! Todos Write Tests Rethink Github Save Add Code Comments Add Night Mode LicenseMIT Free Software, Hell Yeah!","raw":null,"content":null},{"title":"categories","date":"2016-05-09T03:23:34.000Z","updated":"2016-05-09T03:23:34.000Z","comments":true,"path":"categories/index-1.html","permalink":"http://ganmmeng.cn/categories/index-1.html","excerpt":"","keywords":null,"text":"","raw":null,"content":null},{"title":"iOS Developer","date":"2016-04-29T04:39:04.000Z","updated":"2016-04-29T09:45:14.000Z","comments":true,"path":"tags/index.html","permalink":"http://ganmmeng.cn/tags/index.html","excerpt":"","keywords":null,"text":"","raw":null,"content":null},{"title":"categories","date":"2016-04-29T07:50:28.000Z","updated":"2016-04-29T07:50:28.000Z","comments":true,"path":"categories/index.html","permalink":"http://ganmmeng.cn/categories/index.html","excerpt":"","keywords":null,"text":"","raw":null,"content":null},{"title":"tags","date":"2016-05-09T03:23:16.000Z","updated":"2016-05-09T03:23:16.000Z","comments":true,"path":"tags/index-1.html","permalink":"http://ganmmeng.cn/tags/index-1.html","excerpt":"","keywords":null,"text":"","raw":null,"content":null}],"posts":[{"title":"[转]runtime从入门到放弃","slug":"untitled-1463103388379","date":"2016-05-13T01:36:28.000Z","updated":"2016-05-13T01:46:53.000Z","comments":true,"path":"2016/05/13/untitled-1463103388379/","link":"","permalink":"http://ganmmeng.cn/2016/05/13/untitled-1463103388379/","excerpt":"本文为转载原文地址： 孝平的博客 —— runtime从入门到放弃 GG 背景本篇不适应runtime学习，也不涉及runtime长篇大论的理论知识。本篇只是想让你适当的学会放手。而所谓的入门到放弃中的入门则是一些runtime常用apis的认识和使用场景（笔者工作总结）。而所谓的放弃就是不要太过于执着runtime，其实它并没有你想象中的那么好。 来嗨起来现在就让我们开始来旅游runtime的世界吧~！","keywords":null,"text":"本文为转载原文地址： 孝平的博客 —— runtime从入门到放弃 GG 背景本篇不适应runtime学习，也不涉及runtime长篇大论的理论知识。本篇只是想让你适当的学会放手。而所谓的入门到放弃中的入门则是一些runtime常用apis的认识和使用场景（笔者工作总结）。而所谓的放弃就是不要太过于执着runtime，其实它并没有你想象中的那么好。 来嗨起来现在就让我们开始来旅游runtime的世界吧~！ 关联objc_setAssociatedObject 关联，懂点runtime或者不懂runtime的应该都知道这个家伙吧。再或者在分类里也应该见过不少了吧。不讲它用法，只分享笔者经历。 关联的用处一般是用来在分类里定义属性，分别在属性的set和get方法里存放或者获取属性的值。当然还有一个用处也比较实用，则是强引用自己，并且不要释放。强引用自己？嗯哼？怎么有一点晕晕的。好吧，举个列子。需求（可忽略）：比如你有一个ZXPAAA的class，然后ZXPAAA里有show和dismiss方法，并且还有一个delegate回调。然后你还有一个ZXPBBB的class并且有一个函数叫test。现在test函数里有一个局部自动变量ZXPAAA的实例，并且调用ZXPAAA的show方法来弹出一个视图。那么问题来了，这时候你在ZXPBBB的test方法里设置ZXPAAA的delegate为self（self=ZXPBBB）的时候，因为ZXPAAA是局部自动变量，所以在test函数执行完之前，函数内部的ZXPAAA实例变量的引用计数会减一，由于你只是实例化了一下，引用计数为一，然后在减一，故此，此变量会释放，然后在这时候你遵守的ZXPAAA的delegate方法永远不会回调。解决： 那么这时候你就可以在ZXPAAA里的show方法用objc_setAssociatedObject来关联自己并设置retain引用+1。让self不会释放，代码如下：12//ZXPAAA的show 方法里，关联自己，会引用计数+1objc_setAssociatedObject(self, key, self, OBJC_ASSOCIATION_RETAIN_NONATOMIC);目前为止确实是解决了对象自动释放的问题，可问题是对象一直存在呀。内存泄露了尼。不用怕，我们在ZXPAAA的dismiss 方法里释放关联就行了。代码如下：12//ZXPAAA的dismiss 方法里，从关联里移除，设置为nil,会引用计数-1objc_setAssociatedObject(self, key, nil, OBJC_ASSOCIATION_ASSIGN);之前简单封装了一个pickerView工具类里面有用到类似场景，点此进行传输进行查看。 获取class的所有方法（包含私有）核心方法是class_copyMethodList，直接贴代码：12345678910uint count;//返回值是一个Method指针 Method *methodList = class_copyMethodList([NSObject class], &amp;count); for ( int i = 0 ; i &lt; count; i++) &#123; NSLog(@”%@”,NSStringFromSelector(method_getName(methodList[i]))); &#125; //释放 free(methodList);以上这串代码，看似很牛逼。。其实用一句话来形容就是just so so而已。其实最主要的是并没有任何一点实际用处。就算知道了很多私有方法，你想去完美的运用它也需要很多时间成本，而且app store还不会给你上线(企业发布除外)。PS：更多用法直接去查看.h文件即可。 获取class的所有变量（包含私有）核心方法是class_copyIvarList，直接贴代码：1234567891011uint count; //返回值是一个Ivar指针 Ivar *ivarList = class_copyIvarList([UIViewController class], &amp;count); for ( int i = 0 ; i &lt; count; i++) &#123; NSLog(@”%s”,ivar_getName(ivarList[i])); &#125; //释放 free(ivarList); 获取变量和获取方法同理，然并卵，但作为兴趣研究研究的话，还是可以玩玩的。在工程里的实际用处也并不大。PS：更多用法直接去查看.h文件即可。方法替换API为method_exchangeImplementations，交换两个方法的实现，一般用来进行黑魔法调试。虽然也可以用来实现AOP切面编程，but…工程里千万慎用，千万慎用，千万慎用。重要的事情说三遍，至于为什么，原因很简单，不好维护，出了错都不知道飞哪儿去了。而要实现方法切面可使用开源的Aspects。PS: 所谓的黑魔法调试，比如替换init方法，并打印一句话，方便我们知道哪些class被初始化，而AOP切面编程的概念网上也有很多，随意百度一下即可。其他其他还有很多，比如objc_copyClassList获取所有class，method_setImplementation给方法重置一个IMP等等。关于runtime的API有点太多了，就不一一列举了。当然关于runtime知识点远不止这些api这么简单，比如消息转发，重定向等等。写在最后but…. runtime有这么多的api，到底有什么用？答案是并没什么卵用，对，虽然没卵用，但还是很重要，不要问我为什么，就因为它是OC底层，核心。作为一位iOSer，了解这些基础是必须的，起码装逼也有了资本。再退一万步来讲，对于面试，这些也会派上用场。不过对于工作中，确实没啥太大的用处，但是如果写框架的话，用处还是特别大，而且作为程序员也不能一直停留在应用层层面。当然，在工作中用的并不怎么多，但是，还是必须要学的。而标题所谓的放弃的寓意是，让你不要太过于纠结runtime到底有什么用。因为也有很多新人问过笔者runtime到底能做什么….况且现在关于这方面的资料也不多。资料查来查去无非就是消息转发，重定向还有那几个获取变量、方法等几个常用的API而已。当然，对于runtime笔者也连门都没有入。。在此笔者建议新人们一直捉摸不透runtime到底能做什么，倒不如花花时间去研究一下GCD，core foundation等。以上纯属笔者个人给新人的一些建议以及一些runtime肤浅的用法。欢迎吐槽，请勿喷贴。。。转载请注明原文出处","raw":null,"content":null,"categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://ganmmeng.cn/categories/iOS开发/"},{"name":"Runtime","slug":"iOS开发/Runtime","permalink":"http://ganmmeng.cn/categories/iOS开发/Runtime/"}],"tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://ganmmeng.cn/tags/iOS开发/"},{"name":"Runtime","slug":"Runtime","permalink":"http://ganmmeng.cn/tags/Runtime/"}]},{"title":"Block中级进阶（中）——Block实际应用","slug":"untitled-1463040521846","date":"2016-05-12T08:08:41.000Z","updated":"2016-05-12T08:15:35.000Z","comments":true,"path":"2016/05/12/untitled-1463040521846/","link":"","permalink":"http://ganmmeng.cn/2016/05/12/untitled-1463040521846/","excerpt":"前言Block确实很简洁，很方便，特别适合处理较为单一的回调，Block可以省去构建复杂的代理委托关系，快速实现回调的功能，但是有利也有弊，使用Block的适合时常也容易出现一些问题，例如最典型的循环引用，而这些问题也容易被大家所忽视，这篇我会用一个例子引出这一系列的问题 Block的的应用 前面我已经介绍了Block的一些简单的用法，但是在实际开发中，我们并不那样去使用它，一半来说Block大多用于对象与对象之间的通信 BlockButton的封装 下面我就举个栗子：我们来自定义一个Block按钮，以便省去添加事件的繁琐操作 1.首先我们创建一个继承于UIButto的Class 叫做 BlcokButton2.定义好Block类型，创建Block对象 123456789101112131415161718//// BlockButton.h// blockDemo//// Created by GANMENG on 16/5/12.// Copyright © 2016年 BrightOil. All rights reserved.//#import &lt;UIKit/UIKit.h&gt;//定义Block类型typedef void(^ActionBlock)(UIButton *);;@interface BlockButton : UIButton//创建一个Block对象，block创建后内存是分配在栈上的，调用copy方法，会将block从栈上移到堆上。当block声明为全局变量时，我们应该调用block的copy方法。@property (nonatomic, copy) ActionBlock actionBlock;@end","keywords":null,"text":"前言Block确实很简洁，很方便，特别适合处理较为单一的回调，Block可以省去构建复杂的代理委托关系，快速实现回调的功能，但是有利也有弊，使用Block的适合时常也容易出现一些问题，例如最典型的循环引用，而这些问题也容易被大家所忽视，这篇我会用一个例子引出这一系列的问题 Block的的应用 前面我已经介绍了Block的一些简单的用法，但是在实际开发中，我们并不那样去使用它，一半来说Block大多用于对象与对象之间的通信 BlockButton的封装 下面我就举个栗子：我们来自定义一个Block按钮，以便省去添加事件的繁琐操作 1.首先我们创建一个继承于UIButto的Class 叫做 BlcokButton2.定义好Block类型，创建Block对象 123456789101112131415161718//// BlockButton.h// blockDemo//// Created by GANMENG on 16/5/12.// Copyright © 2016年 BrightOil. All rights reserved.//#import &lt;UIKit/UIKit.h&gt;//定义Block类型typedef void(^ActionBlock)(UIButton *);;@interface BlockButton : UIButton//创建一个Block对象，block创建后内存是分配在栈上的，调用copy方法，会将block从栈上移到堆上。当block声明为全局变量时，我们应该调用block的copy方法。@property (nonatomic, copy) ActionBlock actionBlock;@end 在.m文件中给Block添加事件，并且通过ActionBlock回调 12345678910111213141516171819202122232425#import \"BlockButton.h\"@implementation BlockButton- (id)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; //给button添加事件 [self addTarget:self action:@selector(action:) forControlEvents:UIControlEventTouchUpInside]; &#125; return self;&#125;#pragma mark -#pragma mark - Action- (void)action:(UIButton *)sender&#123; //这里一定要判断Block是否为有值的，不然会造成野指针异常。就像是用代理对象回调的时候也要判断delegate 是否有值并且 delegate是否响应了协议里的方法。p.s. 要养成好的编码习惯 if (self.actionBlock) &#123; self.actionBlock(sender); &#125;&#125;@end 就这两个步骤，我们的BlockButton 就封装完了，我们只需要到ViewController中去使用就可以了 123456789101112131415#import \"ViewController.h\"#import \"BlockButton.h\"@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; BlockButton *blockBtn = [[BlockButton alloc] initWithFrame:CGRectMake(100, 100, 100, 35)]; [blockBtn setBackgroundColor:[UIColor redColor]]; blockBtn.actionBlock = ^(UIButton *sender)&#123; NSLog(@\"点击了BlockButton\"); &#125;; [self.view addSubview:blockBtn];&#125;/*---------输出结果---------*/@\"prints: blockDemo[6107:1144064] 点击了BlockButton\" BlockButton的优化 写到这里，有些同学可能会有疑问了，BlockButton只能支持TouchUpInside一种事件类型吗? 难道如果其他事件也想用Block来实现回调还要定义那么多不同的BlockButton吗？ 其实我们只需要稍微修改一下上面的代码就可以让BlockButton可以处理各种事件类型前面有提到过，Block是一个iOS中的对象类型，它可以在方法中作为参数传递 12345678910#import &lt;UIKit/UIKit.h&gt;//定义Block类型typedef void(^ActionBlock)(UIButton *sender);;@interface BlockButton : UIButton//新增的方法，可以传递事件，和Block- (void)gm_addActionForControlEvents:(UIControlEvents)controlEvents callBackWithActionBlock:(ActionBlock)actionBlock;@end 实现这个方法，给BlockButton所持有的actionBlock赋值，添加事件，block回调 1234567891011121314151617181920212223242526272829#import \"BlockButton.h\"@interface BlockButton ()//创建一个Block对象，block创建后内存是分配在栈上的，调用copy方法，会将block从栈上移到堆上。当block声明为全局变量时，我们应该调用block的copy方法。@property (nonatomic, copy) ActionBlock actionBlock;@end@implementation BlockButton#pragma mark -#pragma mark - PublicMethod- (void)gm_addActionForControlEvents:(UIControlEvents)controlEvents callBackWithActionBlock:(ActionBlock)actionBlock&#123; //将公用方法传递过来的block对象赋值给 self.actionBlock = actionBlock; [self addTarget:self action:@selector(action:) forControlEvents:controlEvents];&#125;#pragma mark -#pragma mark - Action- (void)action:(UIButton *)sender&#123; //这里一定要判断Block是否为有值的，不然会造成野指针异常。就像是用代理对象回调的时候也要判断delegate 是否有值并且 delegate是否响应了协议里的方法。p.s. 要养成好的编码习惯 if (self.actionBlock) &#123; self.actionBlock(sender); &#125;&#125;@end 这样我们的blockButton就可以处理各种不同的情况了，而且代码也接近系统的api，用起来十分顺手！😊在ViewController中来使用 12345678910111213141516171819202122#import \"ViewController.h\"#import \"BlockButton.h\"@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; BlockButton *blockBtn = [[BlockButton alloc] initWithFrame:CGRectMake(100, 100, 100, 35)]; [blockBtn setBackgroundColor:[UIColor redColor]]; [blockBtn gm_addActionForControlEvents:UIControlEventTouchUpInside callBackWithActionBlock:^(UIButton *sender) &#123; NSLog(@\"点击了BlockButton\"); &#125;]; [self.view addSubview:blockBtn];&#125;/*---------输出结果---------*/@\"prints: blockDemo[6107:1144064] 点击了BlockButton\" 到这里BlockButton也差不多封装完了，当然你也可以通过使用分类来实现。p.s. 这一篇简单的介绍了Block在实际开发中的回调用法，下一篇我会详细讲解循环引用。❤️❤️❤️❤️","raw":null,"content":null,"categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://ganmmeng.cn/categories/iOS开发/"},{"name":"Block","slug":"iOS开发/Block","permalink":"http://ganmmeng.cn/categories/iOS开发/Block/"}],"tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://ganmmeng.cn/tags/iOS开发/"},{"name":"Block","slug":"Block","permalink":"http://ganmmeng.cn/tags/Block/"}]},{"title":"Block中级进阶（上）","slug":"block-2","date":"2016-05-11T01:48:32.000Z","updated":"2016-05-12T08:31:16.000Z","comments":true,"path":"2016/05/11/block-2/","link":"","permalink":"http://ganmmeng.cn/2016/05/11/block-2/","excerpt":"前言前段时间在公司iOS小组组织了技术分享会，由浅入深的剖析了Block，在这里记录下来，温故而知新 Block和变量 变量按作用域又分有全局变量和局部变量 block代码块内可以引用这两种变量，但是有不同的管理机制 代码说明 在Block里 可以读取变量，但是默认情况是下不能修改变量的值的 12345678int a = 100;void (^myBlock)(int) = ^(int b) &#123; a = 10000; //这里会报错， NSLog(@\"%d %d\\n\", a, b);&#125;;myBlock(110); //调用Block/*---------输出结果---------*/@\"prints: 100 110\"","keywords":null,"text":"前言前段时间在公司iOS小组组织了技术分享会，由浅入深的剖析了Block，在这里记录下来，温故而知新 Block和变量 变量按作用域又分有全局变量和局部变量 block代码块内可以引用这两种变量，但是有不同的管理机制 代码说明 在Block里 可以读取变量，但是默认情况是下不能修改变量的值的 12345678int a = 100;void (^myBlock)(int) = ^(int b) &#123; a = 10000; //这里会报错， NSLog(@\"%d %d\\n\", a, b);&#125;;myBlock(110); //调用Block/*---------输出结果---------*/@\"prints: 100 110\" Block 能读取变量的原理是 copy了一份变量的值,也有说是Block将外部变量以常量的形式存进去。所以在 Block 定义之后修改变量的值，再调用 Block，值依旧是修改前的。换句话说，定义好 Block 之后，修改变量值对 Block 无效。 12345678910int a = 100;void (^myBlock)(int) = ^(int b) &#123; a = 123; //这里会报错， NSLog(@\"%d %d\\n\", a, b);&#125;;a = 10000;//在Block定义后修改a的值myBlock(110); //调用Block/*---------输出结果---------*/@\"prints: 100 110\" __block关键字的用处 如果需要对在block里修改外部定义的变量，那么需要对这个变量前添加一个__block修饰。 12345678__block int a = 100; //在变量前添加__blockvoid (^myBlock)(int) = ^(int b) &#123; a = 10000; //这里不会报错， NSLog(@\"%d %d\\n\", a, b);&#125;;myBlock(110); //调用Block/*---------输出结果---------*/@\"prints: 10000 110\" 如果需要在block定义外面修改变量的值，变量的修改都会影响 block 内部对这个变量的使用，换句话说，block 对变量不再是简单的值复制，而是动态的&quot;监听&quot;值的变化，然后在调用的时候读取变量修改后的值，也需要对这个变量添加一个__block修饰。 12345678910__block int a = 100; //在变量前添加__blockvoid (^myBlock)(int) = ^(int b) &#123; a = 123; //这里会报错， NSLog(@\"%d %d\\n\", a, b);&#125;;a = 10000;//在Block定义后修改a的值myBlock(110); //调用Block 会「动态」识别外部变量的变化，输出10000也就是a最修改后的值/*---------输出结果---------*/@\"prints: 10000 110\" 最后还要注意区别变量和指针所指向的变量 123456789int a= 123;NSMutableString *str = [NSMutableString stringWithFormat:@\"Hello\"];void (^printStr)() = ^() &#123; [str appendString:@\"World\"]; NSLog(@\"%@\",str);&#125;;printStr();/*---------输出结果---------*/@\"prints: HelloWorld\" 为什么在block里面修改string [str appendString:@”World”];不报错是因为str 是指向@”Hello”的函数指针，[str appendString:@”World”];并不是修改 str 所存储的值，本质上是 str 向@”Hello”发送了一条appendString 消息，然后再更改@”Hello”为@”HelloWorld”，而 str 存储的指向@”HelloWorld”对象的指针没有发生变化。所以， block本质上是不能修改变量存储的值，但是消息分发确依旧有效。","raw":null,"content":null,"categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://ganmmeng.cn/categories/iOS开发/"},{"name":"Block","slug":"iOS开发/Block","permalink":"http://ganmmeng.cn/categories/iOS开发/Block/"}],"tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://ganmmeng.cn/tags/iOS开发/"},{"name":"Block","slug":"Block","permalink":"http://ganmmeng.cn/tags/Block/"}]},{"title":"Block 初识","slug":"Block-1","date":"2016-05-09T01:40:41.000Z","updated":"2016-05-12T08:17:03.000Z","comments":true,"path":"2016/05/09/Block-1/","link":"","permalink":"http://ganmmeng.cn/2016/05/09/Block-1/","excerpt":"前言前段时间在公司iOS小组组织了技术分享会，由浅入深的剖析了Block，在这里记录下来，温故而知新 什么是Block Block是iOS4之后新增的一种语法结构，也称之为“闭包（closure）” Block是iOS中一种比较特殊的数据类型 是一个能工作的代码单元，可以在任何需要的时候被执行 本质是轻量级的匿名函数，可以作为其他函数的参数或者返回值。 Block是苹果官方特别推荐使用的数据类型, 应用场景比较广泛 动画 多线程 集合遍历 网络请求回调 新版的AlertController等等等… Block的作用 用来保存某一段代码, 可以在恰当的时间再取出来调用 功能类似于函数和方法","keywords":null,"text":"前言前段时间在公司iOS小组组织了技术分享会，由浅入深的剖析了Block，在这里记录下来，温故而知新 什么是Block Block是iOS4之后新增的一种语法结构，也称之为“闭包（closure）” Block是iOS中一种比较特殊的数据类型 是一个能工作的代码单元，可以在任何需要的时候被执行 本质是轻量级的匿名函数，可以作为其他函数的参数或者返回值。 Block是苹果官方特别推荐使用的数据类型, 应用场景比较广泛 动画 多线程 集合遍历 网络请求回调 新版的AlertController等等等… Block的作用 用来保存某一段代码, 可以在恰当的时间再取出来调用 功能类似于函数和方法 Block的格式直接定义Block变量 Block 的定义格式1返回值类型 (^block变量名)(形参列表) = ^(形参列表) &#123;//do something&#125;; 1.block最简单形式（无形参无返回值）123456void (^block参数名)() = ^&#123;代码块...&#125;;例如:void (^myBlock)() = ^&#123; NSLog(@&quot;doSomething&quot;);&#125;; 2.block中级进阶形式（有形参无返回值）12345678void (^block名称)(参数列表) = ^ (参数列表) &#123; // 代码实现 &#125;;例如:void (^myBlock)(int) = ^(int a)&#123; NSLog(@&quot;a = %d&quot;, a);&#125;; 3.block高级进阶形式（有形参有返回值）12345678返回类型 (^block名称)(参数列表) = ^ 返回类型 (参数列表) &#123; // 代码实现...&#125;;例如:int (^myBlock)(int, int) = ^(int a, int b)&#123; return a + b;&#125;; 调用Block1block变量名(参数); 定义Block的类型12345typedef 返回值 (^Block类型名)(参数);例如:typedef int (^MyFirstBlock)(int); 使用自定义Block类型声明Block对象1234567891011类型名 变量名 = (^ 参数)&#123; retrun result;&#125;;例如：MyFirstBlock myBlock = ^(int a)&#123; return a * a;&#125;; 未完待续","raw":null,"content":null,"categories":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://ganmmeng.cn/categories/iOS开发/"},{"name":"Block","slug":"iOS开发/Block","permalink":"http://ganmmeng.cn/categories/iOS开发/Block/"}],"tags":[{"name":"iOS开发","slug":"iOS开发","permalink":"http://ganmmeng.cn/tags/iOS开发/"},{"name":"Block","slug":"Block","permalink":"http://ganmmeng.cn/tags/Block/"}]},{"title":"建站小记","slug":"untitled-1462496926972","date":"2016-05-06T01:08:46.000Z","updated":"2016-05-09T05:12:45.000Z","comments":true,"path":"2016/05/06/untitled-1462496926972/","link":"","permalink":"http://ganmmeng.cn/2016/05/06/untitled-1462496926972/","excerpt":"前言从小就喜欢玩电脑，一直有一个梦想就是能有一个自己的网站，觉得这是一个很酷的事情，所以经过一个星期的研究和学习，总于搭建了一个属于我&gt; 自己的博客，是不是很酷！？我本来就是一个不善言表的人，虽然博客是顺利的搭建出来了，但是内容嘛。。所以我决定每周都一定要来更新我的博客，可能是技术也可能是其他的文字内容和个人感悟，以此来提升自己也希望能帮助到大家～加油感觉萌！ 关于github1.我的开发环境是OS X，Mac是自带git的所以也免去了配置git的步骤，我的这个博客其实就是使用github Pages，然后配合目前最好用的博客框架—hexo搭建的，hexo是出自一个台湾大学生之手，比起其他的jekll等更好用，而且官方文档也支持中文，很容易看懂，我推荐一篇关于如何搭建个人博客的文章，虽然很容易，但是搭建的过程中也遇到了很多坑。—-&gt;文章传送门 2.最近加了一个github iOS 大牛建的iOS高端开发群，我发现自己真的很菜（之前还有点沾沾自喜觉得该会的都会了）程序猿就是这样，学无止境，你不进步就会慢慢被淘汰，我要学的还有很多多，我今年的目标其实很早就定下来了，例如掌握swift，入门H5，学习React Native，可是现实情况就是几乎还没启动！！！我的计划过开源一些框架，当至少目前为止我的github上还是空空如也！！！我的拖延症是时候治治了！今天写这篇文子也是要给自己提个醒，该醒悟了，什么英雄联盟，手机游戏等等都是麻痹自己的，年纪不小了，已经不是玩那些东西的年纪了！","keywords":null,"text":"前言从小就喜欢玩电脑，一直有一个梦想就是能有一个自己的网站，觉得这是一个很酷的事情，所以经过一个星期的研究和学习，总于搭建了一个属于我&gt; 自己的博客，是不是很酷！？我本来就是一个不善言表的人，虽然博客是顺利的搭建出来了，但是内容嘛。。所以我决定每周都一定要来更新我的博客，可能是技术也可能是其他的文字内容和个人感悟，以此来提升自己也希望能帮助到大家～加油感觉萌！ 关于github1.我的开发环境是OS X，Mac是自带git的所以也免去了配置git的步骤，我的这个博客其实就是使用github Pages，然后配合目前最好用的博客框架—hexo搭建的，hexo是出自一个台湾大学生之手，比起其他的jekll等更好用，而且官方文档也支持中文，很容易看懂，我推荐一篇关于如何搭建个人博客的文章，虽然很容易，但是搭建的过程中也遇到了很多坑。—-&gt;文章传送门 2.最近加了一个github iOS 大牛建的iOS高端开发群，我发现自己真的很菜（之前还有点沾沾自喜觉得该会的都会了）程序猿就是这样，学无止境，你不进步就会慢慢被淘汰，我要学的还有很多多，我今年的目标其实很早就定下来了，例如掌握swift，入门H5，学习React Native，可是现实情况就是几乎还没启动！！！我的计划过开源一些框架，当至少目前为止我的github上还是空空如也！！！我的拖延症是时候治治了！今天写这篇文子也是要给自己提个醒，该醒悟了，什么英雄联盟，手机游戏等等都是麻痹自己的，年纪不小了，已经不是玩那些东西的年纪了！ 关于拖延症以前还没觉得，之前是在一家外包公司干了一年多，天天任务排的满满的，晚上回去有的时候还会为第二天的工作做写准备，现在的这家公司的节奏和之前完全不一样，没有加班，任务比较轻松，每天上班把该完成的做完基本上就可以逛逛论坛，看看大牛的博客等等，但是回到家里之后就再也没有了从前的那种激情（躺在床上玩手机游戏，看泡沫剧等等）虽然也有想过要去学习，比如我会在心里说该看看斯坦福的iOS视频了，该学swift了，该看新买的有关H5的书了，但是每次脑海中都有一个声音：过几天在看，反正时间还多，公司事情也不忙，就这样本来计划15年看完的斯坦福公开课至今都没看完，我在TED的视频中看到有关拖延症的（TED拖延症视频），OMG这不是和我的情况类似吗。。，更可怕的是这还是没有期限的拖延症。p.s. 难道我的大脑里真的有个猴子在掌舵吗。。拖延症太可怕了！！！ 关于hexohexo的安装需要两个前提条件：安装git和nodejs。参见hexo官方文档。nodejs有Mac下的安装包下载地址，安装的时候注意添加node环境变量，然后再用npm install -g hexo一句代码就能安装好了。如果报错那就是权限问题在前面加上sudo就可以了，像这样sudo npm install -g.接下来，我还要谢谢锤神，是他耐心的解答我遇到的各种问题，十分感谢！ 关于ganmmeng.cn我是是一个选择恐惧症患者，这个域名是我话了一上午时间才确定的，毕竟是我人生中第一个域名。。虽然才花了29块钱 ＝＝。。叫ganmmeng是因为我的小名就叫萌萌，我是男的！还有我姓甘，最后我的第一个域名就这样诞生了！当然这些都不是重点，只有坚持写出好的东西，分享自己的经验和心得，这个博客才能有更多的意义吧。 关于我我就是一个普通的程序猿，有一些情怀和理想，经历过成功与失败，但还是热爱我的生活和事业，希望尽自己的努力去生活的快乐。最后放上一段前几天看到的鸡汤 “你20几岁的努力与沉淀，是为30岁以后的优质生活打下基础。现在的我，可以理直气壮的因为贫穷这件事来不断督促自己努力进步。我知道，这辈子也许无法大富大贵，但只要平安健康也是知足。至少，我一直处于努力状态中，奔跑的姿态会告诉我并没有辜负时间” 为自己加油！ 2016.4.29 Gan","raw":null,"content":null,"categories":[{"name":"blog","slug":"blog","permalink":"http://ganmmeng.cn/categories/blog/"}],"tags":[{"name":"杂","slug":"杂","permalink":"http://ganmmeng.cn/tags/杂/"},{"name":"blog","slug":"blog","permalink":"http://ganmmeng.cn/tags/blog/"}]},{"title":"hexo-hey","slug":"untitled-1461912646136","date":"2016-04-29T06:50:46.000Z","updated":"2016-05-09T05:05:43.000Z","comments":true,"path":"2016/04/29/untitled-1461912646136/","link":"","permalink":"http://ganmmeng.cn/2016/04/29/untitled-1461912646136/","excerpt":"Hey hexo 真的很强大an admin plugin for hexo, support hexo v3.xbuilt with gulp + babel + webpackusing es6 + angular + materail + jwt Demohttp://nihgwu.github.io/hexo-hey/username: hexopassowrd: hey About client framework: angular dashboard ui: material authentication: jwt markdown parser: marked markdown style: github-markdown-css markdown editor: codemirror","keywords":null,"text":"Hey hexo 真的很强大an admin plugin for hexo, support hexo v3.xbuilt with gulp + babel + webpackusing es6 + angular + materail + jwt Demohttp://nihgwu.github.io/hexo-hey/username: hexopassowrd: hey About client framework: angular dashboard ui: material authentication: jwt markdown parser: marked markdown style: github-markdown-css markdown editor: codemirror Usage1. install hexo-hey1npm install hexo-hey --save 2. add a admin config section to _config.yml:1234567# Adminadmin: name: hexo password: hey secret: hey hexo expire: 60*1 # cors: http://localhost:3000 cors is optional if you want serve your client in another place(CDN for example) 3. serve hexo1hexo serve then visit http://localhost:4000/admin , and login with the account set in previous step","raw":null,"content":null,"categories":[{"name":"hexo","slug":"hexo","permalink":"http://ganmmeng.cn/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://ganmmeng.cn/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-04-29T04:39:04.000Z","updated":"2016-05-09T05:05:31.000Z","comments":true,"path":"2016/04/29/hello-world/","link":"","permalink":"http://ganmmeng.cn/2016/04/29/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing","keywords":null,"text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","raw":null,"content":null,"categories":[{"name":"ALL","slug":"ALL","permalink":"http://ganmmeng.cn/categories/ALL/"}],"tags":[{"name":"杂","slug":"杂","permalink":"http://ganmmeng.cn/tags/杂/"}]}]}